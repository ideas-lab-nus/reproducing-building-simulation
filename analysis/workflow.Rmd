---
title: "An example workflow of building energy model calibration"
author:
  - Hongyuan Jia
  - Adrian Chong
date: "`r Sys.Date()`"
output:
    html_document:
        toc: yes
        toc_float:
            collapsed: false
            smooth_scroll: false
        fig_caption: yes
        theme:
            version: 4
            bootswath: flatly
---

```{r setup, include = FALSE}
library(tidyverse, warn.conflicts = FALSE) # data analysis
library(lubridate, warn.conflicts = FALSE) # work with date time
library(eplusr)                            # integration with EnergyPlus
library(here)                              # project-root-based file path

# disable verbose information
eplusr_option(verbose_info = FALSE)

# install EnergyPlus v9.1 used in this workflow if necessary
if (!is_avail_eplus(9.1)) install_eplus(9.1, local = TRUE)

# load helper functions
source(here("R/functions.R"))
```

# Workflow

<!-- Create a workflow diagram? -->

- The model we choose with brief description

# Create synthetic meter data

- Read the original baseline model
- Define observed inputs, outputs and calibration parameters
- Run simulation to create synthetic data

## Read original baseline model

Here, we use the reference large office building building for Singapore
developed by Duarte, Raftery and Schiavon.

First, we read the baseline model using the `eplusr::read_idf()` function.

```{r read-ori}
# path of the baseline model
path_base <- here("data-raw/idf/Singapore_Concrete_Benchmark_Model.idf")

# read baseline model
base <- read_idf(path_base)
```

We remove all outputs in the baseline model. So

```{r rem-outputs}
# remove all existing outputs
base$`Output:Variable` <- NULL
base$`Output:Meter:MeterFileOnly` <- NULL
```

## Observed inputs, outputs and calibration parameters

We choose AMY (Annual Meteorological Year) as the observed input. According to
Fig.5 in our paper, AMY together with other separate local weather variables
are commonly used as the observed inputs for calibration.

For calibration parameters, we select 6 most commonly used ones from Fig. 6 of
our paper for demonstration, including:

- Material properties
- Infiltration rate
- Occupancy density
- Lighting power density
- Electric equipment power density
- Cooling setpoint

The mapping between those parameters and corresponding EnergyPlus inputs for
the baseline model are listed in the table blow:

| Calibration parameter            | Class                             | Object                                   | Field                                     | Value |
|----------------------------------+-----------------------------------+------------------------------------------+-------------------------------------------+-------|
| Material properties              | `Material`                        | `SGP_Concrete_200mm`                     | `Conductivity {W/m-K}`                    | 1.442 |
|                                  |                                   |                                          | `Density {kg/m3}`                         | 2400  |
|                                  |                                   |                                          | `Specific Heat {J/kg-K}`                  | 832   |
| Infiltration rate                | `ZoneInfiltration:DesignFlowRate` | All `*_Infiltration` objects for offices | `Air Changes per Hour {1/hr}`             | 0.2   |
| Occupancy density                | `People`                          | All objects for offices                  | `Zone Floor Area per Person {m2/persion}` | 10    |
| Lighting power density           | `Lights`                          | All `*_Lights` objects for offices       | `Watts per Zone Floor Area {W/m2}`        | 15    |
| Electric equipment power sensity | `ElectricEquipment`               | All `*_Equip` objects for offices        | `Watts per Zone Floor Area {W/m2}`        | 14    |
| Cooling setpoint                 | `Schedule:Compact`                | `Sch_Zone_Cooling_Setpoint_Wo_Solar`     | `Field 4`                                 | 24    |
|                                  |                                   | `Sch_Zone_Cooling_Setpoint_Solar`        | `Field 4`                                 | 23    |

For observed output, we choose hourly building electricity consumption. From
Fig. 7 in our paper, we can see that all calibration parameters we select
are commonly used together with building electricity consumption in
calibration studies we investigated. The corresponding output variable in
EnergyPlus is `Electriity: Building` with `Hourly` reporting frequency.

Next, we run the baseline model using AMY EPW file to create synthetic observed
output using simulations. The data will present noise-free measurements which
functions as a surrogate for clean sensor data.

Below we made some necessary to the baseline model, including adding the output
meter and setting the begin year of `RunPeriod` objects based on our AMY
weather data. We saved the modifed model as `AMY.idf` in the `data/idf` folder.

```{r add-outputs}
# add hourly building electricity output meter
base$add(Output_Meter = list("Electricity:Building", "Hourly"))

# update RunPeriod to correctly indicate an AMY EPW file is used
base$RunPeriod[[1]]$Name <- "Singapore 2018"
base$RunPeriod[[1]]$`Begin Year` <- 2018

# day of week for start day will be automatically calculated based on begin year
base$RunPeriod[[1]]$`Day of Week for Start Day` <- NULL

# save the model
base$save(here("data/idf/base.idf"), overwrite = TRUE)
```

## Run simulation to create synthetic data

Below we ran an annual simulation using the AMY EPW stored in
`data-raw/epw/AMY` folder.

```{r run-base}
# path of AMY EPW
path_epw_amy <- here("data-raw/epw/AMY/SGP_SINGAPORE-CHANGI-AP_486980_18.epw")

# run annual simulation for AMY
base$run(path_epw_amy, here("data/sim/base"), echo = FALSE)
```

Once the simulation completed, we extracted the output using `$report_data()`
method, convert the unit of electricity from Joules to kWh and save the values
together with the timestamp to a csv file named `synthetic_meter.csv` in the
`data` folder.

```{r meter-base}
meter_base <- base %>% extract_electricity()

# save synthetic meter data
write_csv(meter_base, here("data/synthetic_meter.csv"))
```

# Create the initial test model to be calibrated

In order to create a test model for calibration, we modified the values of 6
calibration parameters in the baseline model.

## Read the baseline model

```{r read-init}
# read the baseline model as the starting point for the test model
init <- read_idf(here("data/idf/base.idf"))
```

## Create the initial test model

```{r create-init}
update_material(init, conductivity = 0.8, density = 3800, specific_heat = 600)
update_infiltration(init, infil = 1)
update_people(init, people = 15)
update_lights(init, lpd = 12)
update_equip(init, epd = 10)
update_setpoint(init, core = 26, perimeter = 25)

# save
init$save(here("data/idf/init.idf"), overwrite = TRUE)
```

# Evaluate the performance of the initial init model

## Run initial simulation with IWEC

```{r sim-initial}
# read the initial test model
init <- read_idf(here("data/idf/init.idf"))
# get the file path of IWEC EPW file
path_epw_iwec <- here("data-raw/epw/IWEC/SGP_Singapore.486980_IWEC.epw")

# run annual simulation
init$run(path_epw_iwec, here("data/sim/init"), echo = FALSE)
```

## Extract the simulation results

```{r res-initial}
meter_init <- init %>% extract_electricity()
```

## Visualize the trend

```{r plot-init}
# select one week in July to examine the discrepancy
meter_init %>% weekly_compare(7, 1)
```

## Calculate the statistical indicators

```{r stats-init}
stats_init <- meter_init %>% cal_stats()
```

Current calibration creteria in ASHRAE Guideline 14 for NMBE and CVRMSE is 10%
and 30% respectively.

The initial NMBE and CV(RMSE) is `r stats_init["nmbe"]` and
`r stats_init["cvrmse"]`, respectively.

# Use AMY

```{r run-amy}
# read the initial test model
init <- read_idf(here("data/idf/init.idf"))
# path of AMY EPW
path_epw_amy <- here("data-raw/epw/AMY/SGP_SINGAPORE-CHANGI-AP_486980_18.epw")

# run annual simulation
init$run(path_epw_amy, here("data/sim/amy"), echo = FALSE)
```

```{r stats-amy}
meter_amy <- init %>% extract_electricity()

meter_amy %>% weekly_compare(7, 1)

stats_amy <- meter_amy %>% cal_stats()
```

After using AMY EPW file, the CV(RMSE) is `r stats_amy["cvrmse"]` and `r stats_amy["nmbe"]`.

# Use optimization to calibrate the model

```{r fun-optim}
# define a fitness function which takes all calibration parameters as input and
# return the CV(RMSE) and NMBE as output
calib_fitness <- function(conductivity, density, specific_heat, infil, people,
                          lpd, epd, core, perimeter,
                          gen, # generation index used to save model and results
                          ind  # individual index used to save model and results
) {
    # read the initial model
    idf <- eplusr::read_idf(here::here("data/idf/init.idf"))

    # update calibration parameter based on input
    update_material(idf, conductivity = conductivity, density = density,
        specific_heat = specific_heat)
    update_infiltration(idf, infil = infil)
    update_people(idf, people = people)
    update_lights(idf, lpd = lpd)
    update_equip(idf, epd = epd)
    update_setpoint(idf, core = core, perimeter = perimeter)

    # save model into corresponding generation folder in 'data/idf'
    ## contruct generation folder
    dir_gen <- sprintf("Gen%i", gen)
    ## contruct individual model path
    idf_ind <- sprintf("%s_Ind%i.idf", dir_gen, ind)
    ## save
    idf$save(here::here("data/idf", dir_gen, idf_ind), overwrite = TRUE)

    # run simulation
    path_epw_amy <- here::here("data-raw/epw/AMY/SGP_SINGAPORE-CHANGI-AP_486980_18.epw")
    ## contruct individual simulation output path
    dir_out <- here::here("data/sim", dir_gen, sprintf("%s_Ind%i", dir_gen, ind))
    ## run simulation with AMY
    idf$run(path_epw_amy, dir_out, echo = FALSE)

    # calculate statistical indicators
    stats <- cal_stats(idf)

    # generate a plot with inputs and outputs
    p <- weekly_compare(idf, month = 7, week = 1) +
        ggplot2::labs(
            title = sprintf("Gen: %i, Ind: %i; NMBE: %s; CV(RMSE): %s",
                gen, ind, stats["nmbe"], stats["cvrmse"]
            ),
            subtitle = paste0(
                "Conductivity: "       , round(conductivity  , 2) , " W/m-K\n"     ,
                "Density: "            , round(density       , 2) , " kg/m3\n"     ,
                "Specific Heat: "      , round(specific_heat , 2) , " J/kg-K\n"    ,
                "Infiltration Rate: "  , round(infil         , 2) , " 1/hour\n"    ,
                "People Density: "     , round(people        , 2) , " m2/person\n" ,
                "LPD: "                , round(lpd           , 2) , " W/m2\n"      ,
                "EPD: "                , round(epd           , 2) , " W/m2\n"      ,
                "Core Setpoint: "      , round(core          , 2) , " C\n"         ,
                "Perimeter Setpoint: " , round(perimeter     , 2) , " C\n"
            )
        )
    ## contruct individual plot path
    png_ind <- sprintf("%s_Ind%i.png", dir_gen, ind)
    ## create the folder to store plot of each generation
    if (!dir.exists(here::here("figures", dir_gen))) {
        dir.create(here::here("figures", dir_gen))
    }
    ## save the plot
    ggplot2::ggsave(here::here("figures", dir_gen, png_ind),
        p, height = 6, width = 10, dpi = 300)

    abs(stats)
}

# define a function to evaluate the fitness in parallel
evaluate_fitness <- function(control, inds, gen) {
    # add generation and individual index
    inds <- purrr::map2(inds, seq_along(inds), ~c(.x, gen, .y))

    # use future framework to run in parallel
    future::plan(future::sequential)
    # future::plan(future::multisession, workers = 6)
    # on.exit(future::plan(future::sequential), add = TRUE)

    fun <- control$task$fitness.fun
    fit <- future.apply::future_mapply(
        function(ind) do.call(fun, as.list(ind)),
        inds, SIMPLIFY = FALSE, future.seed = TRUE
    )

    ecr:::makeFitnessMatrix(do.call(cbind, fit), control)
}

# create a terminator to stop simulation when CV(RMSE) and NMBE meet the
# creteria in ASHRAE Guideline 14
stopOnMeetCreteria <- function(cvrmse = 0.3, nmbe = 0.1) {
    condition.fun <- function(log) {
        # fitness of current individual
        fit <- log$env$pop[[log$env$n.gens]]$fitness
        fit <- fit[, ncol(fit)]
        # check if creteria are met
        fit["nmbe"] <= nmbe && fit["cvrmse"] <= cvrmse
    }

    ecr::makeTerminator(
        condition.fun,
        name = "MeetCalibrationCreteria",
        message = sprintf("Calibration creteria (CVRMSE=%s, NMBE=%s) has been met", cvrmse, nmbe)
    )
}
```

```{r optim}
# define the serach space of each parameter
space_param <- dplyr::tribble(
    ~parameter       , ~lower, ~upper,
     "conductivity"  ,    0.5,   2.0 ,
     "density"       ,   1000,  3000 ,
     "specific_heat" ,    600,  1000 ,
     "infil"         ,      0,    3  ,
     "people"        ,      5,   15  ,
     "lpd"           ,     10,   20  ,
     "epd"           ,     10,   20  ,
     "core"          ,     20,   26  ,
     "perimeter"     ,     20,   26
)

# define setup values
MU <- 2L     # number of individuals per generation
LAMBDA <- 2L # number of generations

# define an ecr control object to store information on the objective function
control <- ecr::initECRControl(calib_fitness, n.objectives = 2, minimize = TRUE)
# initial a logger to store population and fitness
log <- ecr::initLogger(control, log.pop = TRUE)
# initial archive of Pareto front
pareto <- ecr::initParetoArchive(control)

# set evolutionary operators
# use no priors and set all parameters to follow uniform distribution
control <- ecr::registerECROperator(control, "mutate", ecr::mutUniform,
    lower = space_param$lower, upper = space_param$upper)
control <- ecr::registerECROperator(control, "recombine", ecr::recCrossover)
control <- ecr::registerECROperator(control, "selectForMating", ecr::selSimple )
control <- ecr::registerECROperator(control, "selectForSurvival", ecr::selNondom)

# initialize population of MU random values
pop <- ecr::initPopulation(
    MU, ecr::genReal, n.dim = nrow(space_param),
    lower = space_param$lower, upper = space_param$upper)

# evaluate fitness of initial population
fit <- evaluate_fitness(control, pop, 0)

# save fitness in population
for (i in seq_along(pop)) attr(pop[[i]], "fitness") <- fit[, i]

# update log
ecr::updateLogger(log, pop, fit, MU)

# run evolutionary loop
repeat {
    cat(sprintf("Generation [%i]\n", log$env$n.gens))

    # generate offspring
    cat("  * Generate offspring\n")
    offspring <- ecr::generateOffspring(control, pop, fit, LAMBDA, p.recomb = 0.7, p.mut = 0.1)

    cat("  * Evaluate fitness values\n")
    fit_offspring <- evaluate_fitness(control, pop, log$env$n.gens)

    # save fitness in population
    for (i in seq_along(pop)) attr(pop[[i]], "fitness") <- fit[, i]

    cat("  * Prepare next generation\n")
    res <- ecr::replaceMuPlusLambda(control, pop, offspring, fit, fit_offspring)

    pop <- res$population
    fit <- res$fitness

    # do some logging
    cat("  * Update log\n")
    ecr::updateLogger(log, pop, fit, MU)

    cli::cat_line("  * Check whether terminator conditions are met")
    stop_obj <- ecr:::doTerminate(log, list(stopOnMeetCreteria(cvrmse = 0.3, nmbe = 0.1)))

    if (length(stop_obj) > 0L) {
        cat("Terminated:\n")
        cat(sprintf("  < %s: %s >\n", stop_obj$name, stop_obj$message))
        break
    }
}

result <- ecr:::makeECRResult(control, log, pop, fit, stop_obj)
```

# Session Info

```{r session-info}
sessionInfo()
```
