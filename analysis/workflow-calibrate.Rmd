---
title: "An example workflow of building energy model calibration"
author:
  - Hongyuan Jia
  - Adrian Chong
date: "`r Sys.Date()`"
output:
    html_document:
        toc: yes
        toc_float:
            collapsed: false
            smooth_scroll: true
        highlight: tango
        fig_caption: yes
        theme:
            version: 4
            bootswath: flatly
---

```{r setup, include = FALSE}
# by default, only show code
knitr::opts_chunk$set(echo = TRUE, results = "hide")

library(tidyverse, warn.conflicts = FALSE) # data analysis
library(lubridate, warn.conflicts = FALSE) # work with date time
library(eplusr)                            # integration with EnergyPlus
library(here)                              # project-root-based file path

# disable verbose information
eplusr_option(verbose_info = FALSE)

# install EnergyPlus v9.1 used in this workflow if necessary
if (!is_avail_eplus(9.1)) install_eplus(9.1, local = TRUE)

# load utility functions
source(here("R/utils.R"))
# load functions to calculate statistical indicator
source(here("R/stats.R"))
# load measures to modify the model
source(here("R/measures.R"))
# load functions to read or extract data from simulations
source(here("R/data.R"))
# load fitness functions for optimization
source(here("R/optim.R"))

# for reproducibility
set.seed(1)
```

# Workflow

<!-- Create a workflow diagram? -->

- The model we choose with brief description

## Observed inputs, outputs and calibration parameters

We choose AMY (Annual Meteorological Year) as the observed input.
AMY together with other separate local weather variables are commonly used as
the observed inputs for calibration.

For calibration parameters, we select 7 commonly used ones for demonstration,
including:

- Material properties. Here materials include the exterior wall insulation and
  exterior window
- Infiltration rate
- Occupancy density
- Lighting power density
- Electric equipment power density
- Cooling setpoint
- Heating setpoint

The mapping between those parameters and corresponding EnergyPlus inputs for
the baseline model are listed in the table blow:

| #  | Calibration parameter            | Class                                | Object                               | Field                                      | Value    |
|----+----------------------------------+--------------------------------------+--------------------------------------+--------------------------------------------+----------|
| 1  | Material properties              | `Material`                           | `Steel Frame NonRes Wall Insulation` | `Conductivity {W/m-K}`                     | 0.049    |
| 2  |                                  |                                      |                                      | `Density {kg/m3}`                          | 265.0    |
| 3  |                                  |                                      |                                      | `Specific Heat {J/kg-K}`                   | 836.8    |
| 4  |                                  | `WindowMaterial:SimpleGlazingSystem` | `NonRes Fixed Assembly Window`       | `U-Factor {W/m2-K}`                        | 3.237    |
| 5  |                                  |                                      |                                      | `Solar Heat Gain Coefficient`              | 0.39     |
| 6  | Infiltration rate                | `ZoneInfiltration:DesignFlowRate`    | All `*_Infiltration` objects         | `Flow per Exterior Surface Area {m3/s-m2}` | 0.000302 |
| 7  | Occupancy density                | `People`                             | All objects for offices              | `Zone Floor Area per Person {m2/persion}`  | 18.58    |
| 8  | Lighting power density           | `Lights`                             | All `*_Lights` objects for offices   | `Watts per Zone Floor Area {W/m2}`         | 10.76    |
| 9  | Electric equipment power sensity | `ElectricEquipment`                  | All `*_Equip` objects for offices    | `Watts per Zone Floor Area {W/m2}`         | 10.76    |
| 10 | Cooling setpoint                 | `Schedule:Compact`                   | `CLGSETP_SCH`                        | `Field 6`                                  | 24       |
| 11 | Heating setpoint                 | `Schedule:Compact`                   | `HTGSETP_SCH`                        | `Field 6`                                  | 21       |

For observed output, we choose hourly building electricity consumption. The
corresponding output variable in EnergyPlus is `Electriity: Building` with
`Hourly` reporting frequency.

# Create the initial test model to be calibrated

## Read the model

```{r read-init}
# path of the model
path <- here("data-raw/idf/RefBldgMediumOfficeNew2004_Chicago.idf")

# read the model as the starting point for the test model
init <- read_idf(path)
```

## Create the initial test model

In order to create a test model for calibration, we modified the values of 11
calibration parameters in the model.

```{r offset}
offset <- 0.30
lower <- 1 - offset
upper <- 1 + offset
```

For demonstration, we set the initial parameter values before calibration to a
random value in Â± `r scales::percent(offset)` of the "real" value.

```{r param-init}
# actual parameter values in the model
real_conductivity  <- 0.049
real_density       <- 265.0
real_specific_heat <- 836.8
real_u_value       <- 3.237
real_SHGC          <- 0.39
real_infiltration  <- 0.000302
real_people        <- 18.58
real_lpd           <- 10.76
real_epd           <- 10.76
real_clg_sp        <- 24
real_htg_sp        <- 21

# initial parameter values for calibration
init_conductivity  <- runif(1, real_conductivity  * lower, real_conductivity  * upper)
init_density       <- runif(1, real_density       * lower, real_density       * upper)
init_specific_heat <- runif(1, real_specific_heat * lower, real_specific_heat * upper)
init_u_value       <- runif(1, real_u_value       * lower, real_u_value       * upper)
init_SHGC          <- runif(1, real_SHGC          * lower, real_SHGC          * upper)
init_infiltration  <- runif(1, real_infiltration  * lower, real_infiltration  * upper)
init_people        <- runif(1, real_people        * lower, real_people        * upper)
init_lpd           <- runif(1, real_lpd           * lower, real_lpd           * upper)
init_epd           <- runif(1, real_epd           * lower, real_epd           * upper)
init_clg_sp        <- runif(1, real_clg_sp        * lower, real_clg_sp        * upper)
init_htg_sp        <- runif(1, real_htg_sp        * lower, real_htg_sp        * upper)
```

Below we made some necessary to the model, including adding the output meter and
setting the begin year of `RunPeriod` objects based on our synthetic meter data.

After this, we update the model based on the initial parameter values generated
above and saved the model as `Init.idf` in the `data/idf` folder.

```{r model-init}
# remove all existing outputs
init$`Output:Variable` <- NULL
init$`Output:Meter` <- NULL

# add hourly building electricity output meter
init$add(Output_Meter = list("Electricity:Building", "Hourly"))

# make sure weater file is used
init$SimulationControl$Run_Simulation_for_Weather_File_Run_Periods <- "Yes"

# update RunPeriod to correctly indicate an AMY EPW file is used
init$RunPeriod$annual$set(
    name = "Philadelphia 2014",
    begin_year = 2014,
    day_of_week_for_start_day = "Wednesday"
)

update_insulation(init,
    conductivity = init_conductivity,
    density = init_density,
    specific_heat = init_specific_heat
)
update_window(init, u_value = init_u_value, SHGC = init_SHGC)
update_infiltration(init, flow_per_area = init_infiltration)
update_people(init, people = init_people)
update_lights(init, lpd = init_lpd)
update_equip(init, epd = init_epd)
update_setpoint(init, cooling = init_clg_sp, heating = init_htg_sp)

# save
init$save(here("data/idf/Init.idf"), overwrite = TRUE)
```

# Evaluate the performance of the initial init model

## Run initial simulation with TMY3 weather

```{r sim-init}
# file path of TMY3 EPW file
path_epw_tmy3 <- here("data-raw/epw/TMY3/USA_PA_Philadelphia.Intl.AP.724080_TMY3.epw")

# run annual simulation
init$run(path_epw_tmy3, here("data/sim/Init"), echo = FALSE)
```

## Extract the simulation results

```{r result-init}
meter_init <- init %>% extract_electricity()
```

## Visualize the trend

```{r plot-init}
# select one week in July to examine the discrepancy
meter_init %>% weekly_compare(7, 1)
```

## Calculate the statistical indicators

```{r stats-init}
stats_init <- meter_init %>% cal_stats()
```

Current calibration creteria in ASHRAE Guideline 14 for NMBE and CVRMSE is 10%
and 30% respectively.

The initial NMBE and CV(RMSE) is `r stats_init["nmbe"]` and
`r stats_init["cvrmse"]`, respectively.

# Use AMY

```{r model-amy}
# read the initial test model
amy <- read_idf(here("data/idf/Init.idf"))

# path of AMY EPW
path_epw_amy <- here("data-raw/epw/AMY/PA_PHILADELPHIA_720304_14-13.epw")

# run annual simulation
amy$run(path_epw_amy, here("data/sim/AMY"), echo = FALSE)
```

## Extract the simulation results

```{r result-amy}
meter_amy <- amy %>% extract_electricity()
```

## Visualize the trend

```{r plot-amy}
# select one week in July to examine the discrepancy
meter_amy %>% weekly_compare(7, 1)
```

## Calculate the statistical indicators

```{r stats-amy}
stats_amy <- meter_amy %>% cal_stats()
```

Ater using the AMY weather file, the NMBE and CV(RMSE) is `r stats_amy["nmbe"]`
and `r stats_amy["cvrmse"]`, respectively.

# Use optimization to calibrate the model

```{r optim}
# define the serach space of each parameter
space_param <- dplyr::tribble(
    ~parameter       , ~real             , ~lower                     , ~upper                     ,
     "conductivity"  , real_conductivity  , real_conductivity  * lower , real_conductivity  * upper ,
     "density"       , real_density       , real_density       * lower , real_density       * upper ,
     "specific_heat" , real_specific_heat , real_specific_heat * lower , real_specific_heat * upper ,
     "u_value"       , real_u_value       , real_u_value       * lower , real_u_value       * upper ,
     "SHGC"          , real_SHGC          , real_SHGC          * lower , real_SHGC          * upper ,
     "infiltration"  , real_infiltration  , real_infiltration  * lower , real_infiltration  * upper ,
     "people"        , real_people        , real_people        * lower , real_people        * upper ,
     "lpd"           , real_lpd           , real_lpd           * lower , real_lpd           * upper ,
     "epd"           , real_epd           , real_epd           * lower , real_epd           * upper ,
     "cooling"       , real_clg_sp        , real_clg_sp        * lower , real_clg_sp        * upper ,
     "heating"       , real_htg_sp        , real_htg_sp        * lower , real_htg_sp        * upper
)

# define setup values
MU <- 4L      # number of individuals per generation
LAMBDA <- 4L  # number of offspring
MAX_GEN <- 20L # maximum of generation

# define an ecr control object to store information on the objective function
control <- ecr::initECRControl(calib_fitness, n.objectives = 2, minimize = TRUE)
# initial a logger to store population and fitness
log <- ecr::initLogger(control, log.pop = TRUE)
# initial archive of Pareto front
pareto <- ecr::initParetoArchive(control)

# set evolutionary operators
# use no priors and set all parameters to follow uniform distribution
control <- ecr::registerECROperator(control, "mutate", ecr::mutUniform,
    lower = space_param$lower, upper = space_param$upper)
control <- ecr::registerECROperator(control, "recombine", ecr::recCrossover)
control <- ecr::registerECROperator(control, "selectForMating", ecr::selSimple )
control <- ecr::registerECROperator(control, "selectForSurvival", ecr::selNondom)

# initialize population of MU random values
pop <- ecr::initPopulation(
    MU, ecr::genReal, n.dim = nrow(space_param),
    lower = space_param$lower, upper = space_param$upper)

# evaluate fitness of initial population
fit <- evaluate_fitness(control, pop, 0, workers = 4)

# save fitness in population
for (i in seq_along(pop)) attr(pop[[i]], "fitness") <- fit[, i]

# update log
ecr::updateLogger(log, pop, fit, MU)

# run evolutionary loop
repeat {
    cat(sprintf("Generation [%i]\n", log$env$n.gens))

    # generate offspring
    cat("  * Generate offspring\n")
    offspring <- ecr::generateOffspring(control, pop, fit, LAMBDA, p.recomb = 0.7, p.mut = 0.1)

    cat("  * Evaluate fitness values\n")
    fit_offspring <- evaluate_fitness(control, pop, log$env$n.gens, workers = 4)

    # save fitness in population
    for (i in seq_along(pop)) attr(pop[[i]], "fitness") <- fit[, i]

    cat("  * Prepare next generation\n")
    res <- ecr::replaceMuPlusLambda(control, pop, offspring, fit, fit_offspring)

    pop <- res$population
    fit <- res$fitness

    # do some logging
    cat("  * Update log\n")
    ecr::updateLogger(log, pop, fit, MU)

    cli::cat_line("  * Check whether terminator conditions are met")
    stop_obj <- ecr:::doTerminate(log, list(
        stopOnMeetCreteria(cvrmse = 0.3, nmbe = 0.1),
        ecr::stopOnIters(MAX_GEN)
    ))

    if (length(stop_obj) > 0L) {
        cat("Terminated:\n")
        cat(sprintf("  < %s: %s >\n", stop_obj$name, stop_obj$message))
        break
    }
}

result <- ecr:::makeECRResult(control, log, pop, fit, stop_obj)
```

# Calibration results

The final calibration results are shown in table blow.

```{r res-calib, results = "asis"}
result_param <- result$pareto.set %>%
    transpose() %>%
    map(unlist) %>%
    set_names(space_param$parameter)

result_stats <- result$pareto.set %>%
    map(attr_getter("fitness")) %>%
    transpose() %>%
    map(unlist)

result_calib <- bind_cols(result_param, result_stats) %>%
    mutate(index = seq_len(n())) %>%
    select(index, everything()) %>%
    filter(nmbe != 1E9, cvrmse != 1E9)

result_calib %>%
    gt::gt() %>%
    gt::fmt_number(2:ncol(result_calib)) %>%
    gt::fmt_percent(vars(nmbe, cvrmse)) %>%
    gt::tab_header(title = "Calibration results") %>%
    gt::cols_label(
        index = "#",
        conductivity = gt::html("Insulation conductivity (W/(m K))"),
        density = gt::html("Insulation density (kg/m<sup>3</sup>)"),
        specific_heat = gt::html("Insulation specific heat (J/(kg K))"),
        u_value = gt::html("Window U value [W/(m<sup>2</sup> K)]"),
        SHGC = gt::html("Window SHGC"),
        infiltration = gt::html("Infiltration per floor area (m<sup>3</sup>/(s m<sup>2</sup>))"),
        people = gt::html("People density (m<sup>2</sup>/person)"),
        lpd = gt::html("Lighting power density (W/m<sup>2</sup>)"),
        epd = gt::html("Equipment power density (W/m<sup>2</sup>)"),
        cooling = gt::html("Cooling setpoint (&deg;C)"),
        heating = gt::html("Heating setpoint (&deg;C)"),
        nmbe = "NMBE",
        cvrmse = "CV(RMSE)") %>%
    gt::tab_style(
        style = gt::cell_text(weight = "bold"),
        locations = gt::cells_column_labels(1:ncol(result_calib)))
```

# Session Info

```{r session-info, results = "markup"}
sessionInfo()
```
